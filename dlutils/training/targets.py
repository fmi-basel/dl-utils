from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

from scipy.ndimage.morphology import grey_closing
from scipy.ndimage.morphology import grey_dilation
from scipy.ndimage.morphology import distance_transform_edt
from scipy.ndimage import find_objects
from scipy.ndimage.filters import gaussian_filter
from skimage.segmentation import find_boundaries

from dlutils.preprocessing.normalization import min_max_scaling

import numpy as np


def generate_border_map(segmentation, border_width=1, decay=10):
    '''calculate border target map from instance segmentation.

    Notes
    -----
    Border map is a detection heatmap calculated as

     f(x) = exp( - dt(x) / decay )

    where dt(..) is the distance transform from the segmentation
    border pixels. If segmentation is an instance segmentation,
    i.e. invidual labels for each instance, then the border will
    outline different instances.

    '''
    border_width = max(border_width - 2, 0)

    boundary = find_boundaries(
        segmentation, connectivity=2, mode='thick', background=0)
    if border_width > 0:
        grey_dilation(boundary, border_width, output=boundary)
    boundary = np.logical_not(boundary)
    boundary = boundary.astype(np.float32)
    boundary = distance_transform_edt(boundary)
    boundary = np.exp(-boundary / decay)
    return boundary


def generate_separator_map(segmentation, border_width=4, decay=10, reach=25):
    '''calculate borders between foreground instances.

    Notes
    -----
    Border map is a detection heatmap calculated as

     f(x) = np.exp( - dt(x) / decay )

    where dt(..) is the distance transform from the segmentation
    border pixels. If segmentation is an instance segmentation,
    i.e. invidual labels for each instance, then the border will
    outline different instances.

    '''
    border_width = max(border_width - 2, 0)

    dist, indices = distance_transform_edt(
        segmentation == 0, return_indices=True, return_distances=True)
    closest = segmentation[indices.tolist()]

    boundary = find_boundaries(closest, connectivity=2, mode='thick')

    if border_width > 0:
        grey_dilation(boundary, border_width, output=boundary)

    # limit separators to areas close to cells.
    boundary = np.logical_and(boundary, dist <= reach)

    # turn binary separator map into heatmap
    boundary = np.logical_not(boundary)
    boundary = boundary.astype(np.float32)
    boundary = distance_transform_edt(boundary)
    boundary = np.exp(-boundary / decay)
    return boundary


def generate_masked_separator(segmentation, maskval,
                              truncate=0.1, *args, **kwargs):
    '''returns a masked version of the separator map generated by
    generate_separator_map.
    
    Notes
    -----
    The distance is individually normalized to [0,1] for each cluster.
    '''
    separator = generate_separator_map(segmentation, *args, **kwargs)
    mask = np.logical_and(segmentation == 0, separator <= truncate)
    separator[mask] = maskval
    return separator

def generate_distance_transform(segmentation, sampling=1.0, sigma=0.5):
    '''calculate the distance transform separately for each labeled 
    cluster.
    
    '''
    if not isinstance(segmentation, np.ndarray) or segmentation.dtype != int:
        raise ValueError('Expected an integer numpy.ndarray as segmentation labels, got: {}, {}'.format(
                                type(segmentation), segmentation.dtype))
    if sampling is None:
        sampling = 1.0
    
    transform = np.zeros_like(segmentation, dtype=np.float)
    for label in range(1,segmentation.max()+1):
        loc = find_objects(segmentation == label)
        if loc:
            loc = loc[0]
            # expand the slice to make sure a borders are visible when labels
            # are aligned vertically or horizontally 
            loc = tuple(slice(max(0,sli.start-1),sli.stop+1) for sli in loc)
            
            transformed_label = distance_transform_edt(segmentation[loc]==label, sampling=sampling)
            transform[loc] += min_max_scaling(transformed_label)
    
    transform = gaussian_filter(transform, sigma=0.5/np.asarray(sampling))
    transform = min_max_scaling(transform)
    
    return transform
    

def close_segmentation(segmentation, size, **kwargs):
    '''close holes in segmentation maps for training.

    '''
    return grey_closing(segmentation, size=size, **kwargs)
