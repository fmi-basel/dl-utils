from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

from scipy.ndimage.morphology import grey_closing
from scipy.ndimage.morphology import grey_dilation, grey_erosion, morphological_gradient
from scipy.ndimage.morphology import distance_transform_edt
from skimage.segmentation import find_boundaries

import numpy as np


def generate_border_map(segmentation, border_width=1, decay=10):
    '''calculate border target map from instance segmentation.

    Notes
    -----
    Border map is a detection heatmap calculated as

     f(x) = exp( - dt(x) / decay )

    where dt(..) is the distance transform from the segmentation
    border pixels. If segmentation is an instance segmentation,
    i.e. invidual labels for each instance, then the border will
    outline different instances.

    '''
    border_width = max(border_width - 2, 0)

    boundary = find_boundaries(
        segmentation, connectivity=2, mode='thick', background=0)
    if border_width > 0:
        grey_dilation(boundary, border_width, output=boundary)
    boundary = np.logical_not(boundary)
    boundary = boundary.astype(np.float32)
    boundary = distance_transform_edt(boundary)
    boundary = np.exp(-boundary / decay)
    return boundary


def generate_separator_map(segmentation, border_width=4, decay=10, reach=25):
    '''calculate borders between foreground instances.

    Notes
    -----
    Border map is a detection heatmap calculated as

     f(x) = np.exp( - dt(x) / decay )

    where dt(..) is the distance transform from the segmentation
    border pixels. If segmentation is an instance segmentation,
    i.e. invidual labels for each instance, then the border will
    outline different instances.

    '''
    border_width = max(border_width - 2, 0)

    dist, indices = distance_transform_edt(
        segmentation == 0, return_indices=True, return_distances=True)
    closest = segmentation[indices.tolist()]

    boundary = find_boundaries(closest, connectivity=2, mode='thick')

    if border_width > 0:
        grey_dilation(boundary, border_width, output=boundary)

    # limit separators to areas close to cells.
    boundary = np.logical_and(boundary, dist <= reach)

    # turn binary separator map into heatmap
    boundary = np.logical_not(boundary)
    boundary = boundary.astype(np.float32)
    boundary = distance_transform_edt(boundary)
    boundary = np.exp(-boundary / decay)
    return boundary


def generate_masked_separator(segmentation, maskval,
                              truncate=0.1, *args, **kwargs):
    '''returns a masked version of the separator map generated by
    generate_separator_map.
    
    Notes
    -----
    The distance is individually normalized to [0,1] for each cluster.
    '''
    separator = generate_separator_map(segmentation, *args, **kwargs)
    mask = np.logical_and(segmentation == 0, separator <= truncate)
    separator[mask] = maskval
    return separator


def close_segmentation(segmentation, size, **kwargs):
    '''close holes in segmentation maps for training.

    '''
    return grey_closing(segmentation, size=size, **kwargs)
